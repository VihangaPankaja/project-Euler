# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be
# 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
#
# What is the value of the first triangle number to have over five hundred divisors?

import my_math


divisors: int = 500
triangle: __import__('typing').Callable[[int], int] = lambda n: int(n * (n + 1) / 2)           # get triangle number from the term number
prime_list: list[int] = my_math.prime_list_for(divisors)       # generate prime list


## returns all the prime factors for given number ##
def factors_list(n: int)-> list[int]:
    global prime_list
    
    lst: list[int] = []
    
    for i in prime_list:
        if i > n:             # if number larger than currunly checking prime stop looping
            break
        
        while True:
            if n % i == 0:      # check if currunt factor divicable by currunt prime and add to list if
                lst.append(i)
                n /= i          # next factor after divide
            
            else:               # if not divicable stop looping
                break
    
    return lst                  # return prime factor list maybe with same numbers included
###########################################


def above_divisors(divisors: int)-> tuple[int]:
    """ return triangle number that has divisors over given number with divisors found as tupple """
    
    n: int = 1
    while True:
        fac_lst: list[int] = factors_list(triangle(n))     # get prime factor list
        combinations = 1

        ## tottal divicors are equal to multipy of power of same primes that raised to power plus one (x^a * y^b * .... >>>> (a+1)(b+1)*......)
        for i in list(set(fac_lst)):
            combinations *= (fac_lst.count(i) + 1)
        ##################

        if combinations >= divisors:   # if required divicors reached
            break

        n += 1

    return (combinations, triangle(n))


if __name__ == '__main__':
    print(above_divisors(divisors))