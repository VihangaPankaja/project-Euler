""" 
    The sequence of triangle numbers is generated by adding the natural numbers. 
    So the 7th triangle number would be
*       1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 

    The first ten terms would be:
*       1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

    Let us list the factors of the first seven triangle numbers:
*       1  ⟹    1
*       3  ⟹    1,3
*       6  ⟹    1,2,3,6
*       10 ⟹    1,2,5,10
*       15 ⟹    1,3,5,15
*       21 ⟹    1,3,7,21
*       28 ⟹    1,2,4,7,14,28
    We can see that 28 is the first triangle number to have over five divisors.

?   What is the value of the first triangle number to have over five hundred divisors
"""

import my_math
from typing import Callable


def factors_list(n: int) -> list[int]:
    """ returns all the prime factors for given number

    Args:
    ----
        n (int): number

    Returns:
    ----
        list[int]:
    """
    
    global prime_list
    
    lst: list[int] = []
    
    for i in prime_list:
        if i > n:             # if number larger than currently checking prime stop looping
            break
        
        while True:
            if n % i == 0:      # check if currunt factor divisible by currunt prime and add to list if
                lst.append(i)
                n /= i          # next factor after divide
            
            else:               # if not divisible stop looping
                break
    
    return lst                  # return prime factor list maybe with same numbers included


def above_divisors(divisors: int) -> tuple[int]:
    """ return triangle number that has divisors over given number with divisors found as tuple

    Args:
    ----
        divisors (int): how many divisors in number

    Returns:
    ----
        tuple[int]:
    """
    
    n: int = 1
    while True:
        fac_lst: list[int] = factors_list(triangle(n))     # get prime factor list
        combinations = 1

        ## total divisors are equal to multiply of power of same primes that raised to power plus one (xᵃ × yᵇ × .... >>>> (a+1)×(b+1)×......)
        for i in list(set(fac_lst)):
            combinations *= (fac_lst.count(i) + 1)
        ##################

        if combinations >= divisors:   # if required divisors reached
            break

        n += 1

    return (combinations, triangle(n))


if __name__ == '__main__':
    triangle: Callable[[int], int] = lambda n: int(n * (n+1) / 2)           # get triangle number from the term number
    prime_list: list[int] = my_math.prime_list_for(500)                  # generate prime list
    
    print(above_divisors(500))